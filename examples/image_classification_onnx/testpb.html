<html>
  <head>
    <meta charset="utf-8">
    <title>Onnx Importer Test</title>
  </head>
  <body>
    <script src="../../dist/webml-polyfill.js"></script>
    <script src="../third_party/protobuf.min.js"></script>
    <script src="../util/base.js"></script>
    <script src="onnx.js"></script>
    <script src="OnnxModelUtils.js"></script>
    <script src="SqueezeNet.js"></script>
    <script>
     window.onload = async function() {
      async function loadUrl(url) {
        return new Promise((resolve, reject) => {
          let request = new XMLHttpRequest();
          request.open('GET', url, true);
          request.responseType = 'arraybuffer';
          request.onload = _ => {
            if (request.readyState === 4)
              if (request.status === 200)
                resolve(new Uint8Array(request.response));
              else
                reject(new Error('Failed to load ' + url));
          };
          request.send();
        });
      }
      // const INPUT_TENSOR_SIZE = 2*2*3;
      // // const OUTPUT_TENSOR_SIZE = 2*2*3;
      // const INPUT_TENSOR_SIZE = 16*3*256*256;
      // const OUTPUT_TENSOR_SIZE = 16*128*128*64;
      // const INPUT_TENSOR_SIZE = 32*1*64*64;
      // const OUTPUT_TENSOR_SIZE = 32*15*15*128;
      // const INPUT_TENSOR_SIZE = 1*2*100;
      // const OUTPUT_TENSOR_SIZE = 1*2*100;
      // const INPUT_TENSOR_SIZE = 16*1*256*256;
      // const OUTPUT_TENSOR_SIZE = 16*1*256*256;
      // const OUTPUT_TENSOR_SIZE = 254*254*32
      const INPUT_TENSOR_SIZE = 36
      const OUTPUT_TENSOR_SIZE = 9;
      const MODEL_FILE = './model/input_0.pb';
      const backend = 'WASM';

      // let inputTensor = new Float32Array(INPUT_TENSOR_SIZE);
      // let outputTensor = new Float32Array(OUTPUT_TENSOR_SIZE);
      // for (let i = 0; i < inputTensor.length; ++i)
      //   inputTensor[i] = i;
      //   // inputTensor[i] = Math.random();
      //   // inputTensor[0] = 5;

      let result = await loadUrl(MODEL_FILE);
      if (onnx.TensorProto.verify(result))
        throw new Error(`Invalid tensor`);
      let tensor = onnx.TensorProto.decode(result);

      let dataView = new DataView(tensor.rawData.buffer, tensor.rawData.byteOffset, tensor.rawData.byteLength);
      let length = tensor.dims.length ? product(tensor.dims) : 1;
      data = new Float32Array(length);
      for (let i = 0; i < length; ++i) {
        // raw data is stored in little-endian order
        data[i] = dataView.getFloat32(i*Float32Array.BYTES_PER_ELEMENT, true);
      }
      if (tensor.dims.length === 4) {
        // NCHW -> NHWC
        let nhwcData = new Float32Array(data.length);
        const N = tensor.dims[0];
        const C = tensor.dims[1];
        const H = tensor.dims[2];
        const W = tensor.dims[3];
        for (let n = 0; n < N; ++n) {
          for (let c = 0; c < C; ++c) {
            for (let h = 0; h < H; ++h) {
              for (let w = 0; w < W; ++w) {
                nhwcData[n*H*W*C + h*W*C + w*C + c] = data[n*C*H*W + c*H*W + h*W + w];
              }
            }
          }
        }
        data = nhwcData;
      }

      // console.log(inputTensor);
      console.log(data);
    }
    </script>
  </body>
</html>
